# 정규표현식 : 복잡한 문자열을 처리할 때 사용하는 기법, 문자열을 처리하는 "모든 곳"에서 사용하기 때문에 넓은 범위적 사용이 가능하다. 따라서 일종에 또다른 은 프로그래밍 언어라고 생각하면 된다.

# 찾으려는 문자열, 바꿀 문자열의 규칙이 매우 복잡하다면 정규식의 효용성이 크게 증가한다.

1. 정규표현식 기초

- 메타문자 : 뜻을 가진 문자가 아닌 특별한 용도로 사용되는 문자

    0. "[]" : 문자클래스, 괄호 안에 문자들과 매치하라. 어떤 문자든 들어갈 수 있다.
        - Ex1) : [abc] : a,b,c중 한 개의 문자와 매치
        - Ex2) : [from-to] : [a-c]는  abc,[0-5]는 [012345]의미
        - Ex3) : [^0-9] : 0에서 9까지 금지, 즉 숫자문자는 금지.
        - 자주사용되는 [a-zA-Z],[0-9]의 별도 대체 표기법
            1. \d : [0-9] , 숫자와 매치
            2. \D : [^0-9] ,숫자가 아닌 것과 매치
            3. \s : [ \t\n\r\f\v] : space,tab처럼 공백을 표현하는 문자와 매치(whitespace)
            4. \S : [^ \t\n\r\f\v] : whitespace문자가 아닌 것과 매치. 앞에 공백은 공백문자(space).
            5. \w : [a-zA-Z0-9_] : 문자+숫자 와 매치
            6. \W : [^a-zA-Z0-9_] :
    1. "." : \n 줄바꿈 문자를 제외한 모든 문자와 매치\
        - Ex1 ) : a.b : a가 오고 중간에는 \n뺀 모든 문자
        - Ex2 ) : a[.]b : a가 앞에 오고 중간에 점문자하나가 와야함. Dot 문자 그대로 와야하니 혼동은 x.
    2. "^" : "^표현식" 처럼 사용한다. 표현식이 반드시 문자열 맨 앞에서 일치해야 한다. MULTILINE 기능을 사용시 여러 라인에 대해 적용한다.
    3. "$" : "표현식$" 처럼 사용한다.표현식이 반드시 끝자리와 같아야 한다라는 의미이다.
    4. "|" : 또는 의 의미. "a|b"이면 한 자리에 a나 b이다 라는 뜻.
    5. "\A" : ^와 동일한 의미이지만 MULTI~에선 줄과 상관없이 문자열 처음하고만 매치된다.
    6. "\Z" : $와 동일한 의미이며 MULTI~ 옵션 사용시 모든 문자열의 끝과 매치된다.
    7. "\b" : \b정규식\b, whitespace로 둘러쌓인 정규식을 찾는다. 반드시 Row string r""을 사용해야한다.
    8. "\B" : \b와 반대로 둘러쌓인 양옆에 whitespace가 아닌 경우만 찾는다. 즉 문자로 둘러 쌓인 경우다.

    - 반복 메타문자 : 가급적 {}의 사용은 지양한다.
    4. "*" : 반복을 의미한다. *바로 앞에 있는 문자가 0부터 무한대 반복될 수 있음을 뜻한다.
        - EX 1) KB*S : B가 0(없음)~무한대 까지 있을 수 있다.
    5. "+" : 반복을 의미한다. +바로 앞에 있는 문자가 1부터 무한대 반복될 수 있음을 뜻한다.
    6. "{}" : 반복을 의미한다. 4,5와 다르게 범위가 지정된다.
        - EX 1) : ca{2}t : a가 반드시 2번 반복되어야한다.
        - EX 2) : ca{2,}t : a가 반드시 2회 이상 반복
        - EX 3) : ca{,2}t : a가 반드시 2회 이하 반복
        - EX 4) : ca{3,5}t : a가 반드시 3회 이상 5회 이하 반복
    7. "?" : 반복을 의미한다. {0,1}와 동치이다. 모른다의 의미로 해석이 가능하다.
        - EX 1) : jb?kk " b가 없거나 있다.
    

2. 사용법 in python
    1. import re
    2. variable=re.compile("정규표현식")
        - parameter
            1. RegularExp:사용하 정규표현식
            2. Option : re.option 처럼 사용
                - DOTALL/S : 메타문자는 \n를 제외하는 규칙이 있는데 \n을 무시하고 싶을 때 지정. .compile("~",re.S/re.DOTALL)

                - IGNORECASE/I : [a-z]일 떄 A-Z도 읽는 옵션. 대소문자 구별을 무시해준다.
                
                - MULTILINE/M : \n으로 구분된 파일에 각 라인마다 처음 문자열부터 인식시키고자 할 때 사용한다. 즉 첫번째 문자열이나 여러 줄로 나뉜 파일에다가 정규표현식과 함께 사용이 가능한 옵션이다.

                - VERVOSE/X : 정규식은 정말 복잡하다. 하나하나 뜯어 읽기 존나 귀찮고 머리아프다. 사실상 암호수준이다. 그래서 주석을 두면서 풀고싶다. 사용시 [] 안에 whitespace제외한 모든 whitespace는 컴파일시에 제거된다. 줄단위로 #사용해서 주석달기가 가능해진다.
                    ```
                    Re=re.compile(r"&[#](0[0-7]+|[0-9]+|x\w+);",re.X)
                    ->
                    re.compile(r"""
                    &[#]    #start of a numeric
                    (
                        0[0-7]+ # octal form
                        \d+ #Decimal form
                        x\w+ # Hexadecimal
                    ); # Trailing semicolon
                    """)
                    ```


    3. method 사용
        1. .match(검색할문자열) : 문자열 처음부터 정규식과 매치되는 지 조사. 즉 정규표현식의 첫 글자와 문자열의 첫 글자가 다르면 더 이상 조사하지 않는다.
        2. .search(검색할문자열) : 문자열 전체를 검색해서 정규식과 매치되는 지 조사. 문자열 전체를 뒤져서 같은 패턴을 찾아낸다.
        - 1,2 공통 메소드
            - .group() , start/end/span()

        3. .findall(검색할문자열) : 정규식과 매치되는 모~든 문자열을 substring해서 리스트로 돌려준다.
            - EX ) : 정규식 = \d+-\w{,6} ,"659-325 32-68 9897-956 9-9897641" -> 마지막 것만 뺴고 모두 출력이 아니라..! 마지막에 1만 뺴고 출력된다 ㄷㄷ.. 왜냐면 조건식이 저렇기 때문.
        4. finditer : iterable 객체로 findall과 같은 기능이다. iter의 각 객체는 re.match 오브젝트이다.
3. Row String : "\section"을 의도대로 사용위해 r"\\section"처럼 사용하는 것. 
    ```
    r1=re.compile(r"\\sect")
    m=r1.match("\section")
    print(m.group())
    ->
    \sect
    ```

4. 그루핑 : "()" 사용
    - Ex 1) : 그룹이 나누어진다. 특정 정보 획득에 유용
        ```
        st="""park 032-98777-9632 
        jung 02-988-946"""
        gr=re.compile(r"(\w+) ((\d+)[-]\w+)",re.MULTILINE)
        com=gr.findall(st)
        print(com)
        ->
        [('park', '032-98777', '032'), ('jung', '02-988', '02')]
        ```
    - 그룹된 문자열 이름 태그 붙이기 : 가독성이 상당히 떨어지지만 그룹이 복잡하게 10중이상일 시 상당히 효과가 좋다.
        - 방법 : (?P<그룹이름>정규표현식) , (?...)은 확장구문이란 것이라고 한다. 
        - 호출법 : obj.group("그룹이름")


5. 전방탐색
    - 설명 : 정규식 안에 조건식을 넣으며 조건에 넣은 문자는 결과에서 제외된다.(소비되지 않는다 라고 한다.)

    - 긍정형전방탐색 : (?=문자/메타문자) = 문자에 맞을 때 탐색을 종료한다.
    - 부정형전방탐색 : (?!문자/메타문자) = 문자에 맞는 순간 탐색을 하지 않는다.
        ```
        c="avi.exe ces.avi exel.excel"
        r=re.compile(".+(?![.]avi)",re.MULTILINE)
        p=r.findall(c)
        print(p)
        ```